@page "/KubernetesCronJobs"
<PageTitle>More C# Guides: KubernetesCronJobs</PageTitle>
<MudPaper Style="background: #f0f8ff; padding-top: 20px">
    <MudText Typo="Typo.h4" Align="Align.Center">  Using Kubernetes Cron Jobs and Dotnet worker services to scheduled background tasks</MudText>
    <hr style="width:75%; margin: auto; ">
    <MudText Typo="Typo.body1" Style="margin: 30px">
        There are times as a developer that you want to run code periodically. There are few ways to do this in C#. There are two 
        popular libraries, <MudLink Href="https://www.quartz-scheduler.net/" Target="_blank">Quartz</MudLink> and 
        <MudLink Href="https://www.hangfire.io/" Target="_blank">Hangfire</MudLink> that allow you to schedule jobs. Both of these
        libraries suffer from the same problem. Say if you have two jobs (the code you want to run periodically) each in there own library. 
        Either your Hangfire or Quartz project has to reference both of those libraries. So if you want to add or edit a job you have to take 
        your whole scheduler project down which means no jobs run while you are doing a deployment. In summary all your jobs are coupled to
        the scheduler project that uses either Hangfire or Quartz. <br>
        So that is why I think the best way to schedule the running of code is with <MudLink Href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" 
        Target="_blank" >KubernetesCronJobs</MudLink>. KubernetesCronJobs will start a docker container on a repeating schedule. I like to start <MudLink Href="https://docs.microsoft.com/en-us/dotnet/core/extensions/workers"
        Target="_blank">worker service</MudLink> containers
        because worker services have quite a lot of built in functionality in comparison to something like a console app. They are also easy to shut down gracefully when the 
        job is complete.
        <MudText Style="margin-top: 10px" Typo="Typo.h6">prerequisites</MudText>
        <MudList Dense="true">
            <MudListItem>You already have docker installed and know the basics</MudListItem>
            <MudListItem>You have Kubernetes cluster to use and know how to use kubernetes. If not I recommend
                <MudLink Href="https://minikube.sigs.k8s.io/docs/start/" Target="_blank">minikube</MudLink>
            </MudListItem>
        </MudList> 
        <MudText Style="margin-top: 10px" Typo="Typo.h4">Creating our Job</MudText>
        <hr style="width: 60%">
        As I said above we will be using a worker service to run jobs. So navigate to where you want to create you project and open a terminal and run
        <CodeBlock CodeAsString="@newProject"></CodeBlock> 
        The first thing we should do is delete the worker that comes automatically when you create a worker service. So delete the Worker.cs file and remove the line 
        <i style="background-color: #ffffffff;">services.AddHostedService&lt;Worker&gt;();</i> from program.cs <br>
        <br>
        Now lets create our job. Create a file called SampleJob.cs and make it look like so 
        <CodeBlock CodeAsString="@sampleJob"></CodeBlock>
        The code for this job is pretty simple.  It inherits from BackgroundService which means we can add it as a HostedService later. 
        It has two injected services, ILogger and IHostApplicationLifetime. We will use IHostApplicationLifetime to gracefully shut down the application when
        the job is complete. <br>
        The ExecuteAsync method is the entry point for the job. It will log the value of a integer and increment it. When the integer is equal to 10 it will
        shut the application down. In the StopAsync method we log Exiting application. The StopAsync method gets called when ever the 
        application shuts down. <br>
        Now we need to add our job/BackgroundService to program.cs. <br>
        Do so by adding the line <i style="background-color: #ffffffff;">services.AddHostedService&lt;SampleJob&gt;();</i>. Startup.cs
        should look like so.
        <CodeBlock CodeAsString="@program"></CodeBlock>
        And with that our Job is complete. Run it to see if works.  
        <MudText Style="margin-top: 10px" Typo="Typo.h4">Dockerizing our images</MudText>
        <hr style="width: 60%">
    </MudText>
</MudPaper>

@code {
    string newProject = @"dotnet new worker -n ""KubernetesCronJobSampleProject""";

    string sampleJob = @"namespace KubernetesCronJobSampleProject;
public class SampleJob : BackgroundService
{
    private readonly ILogger<SampleJob> _logger;
    private readonly IHostApplicationLifetime _hostApplicationLifetime;
    private int _count = 0;

    public SampleJob(ILogger<SampleJob> logger,IHostApplicationLifetime hostApplicationLifetime)
    {
        _logger = logger;
        _hostApplicationLifetime = hostApplicationLifetime;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            _logger.LogInformation($""Worker running count {_count}"");
            await Task.Delay(1000, stoppingToken);
            _count++;
            
            if(_count >= 10)
            {
                _hostApplicationLifetime.StopApplication();
            }
        }
    }

    public override Task StopAsync(CancellationToken stoppingToken)
    {
        _logger.LogDebug(""Exiting application..."");
        return base.StopAsync(stoppingToken);
    }
}";
string program = @"using KubernetesCronJobSampleProject;

IHost host = Host.CreateDefaultBuilder(args)
    .ConfigureServices(services =>
    {
       services.AddHostedService<SampleJob>();
    })
    .Build();

await host.RunAsync();";
}